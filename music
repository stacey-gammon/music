#!/usr/bin/env python3
"""
Music CLI Tool - Audio processing and looping
"""

import argparse
import subprocess
import sys
import os
import glob
from pathlib import Path

def cleanup_old_temp_files():
    """Clean up any leftover temporary files from previous runs"""
    tmp_dir = Path("tmp")
    if tmp_dir.exists():
        # Remove old temp files (older than 1 hour)
        import time
        current_time = time.time()
        for file_path in tmp_dir.glob("*"):
            if file_path.is_file() and (current_time - file_path.stat().st_mtime) > 3600:
                try:
                    file_path.unlink()
                except:
                    pass

def parse_time(time_str):
    """Parse time string like ':10' or '1:30' into seconds"""
    if time_str.startswith(':'):
        # Just seconds
        return float(time_str[1:])
    elif ':' in time_str:
        # Minutes:seconds
        parts = time_str.split(':')
        return float(parts[0]) * 60 + float(parts[1])
    else:
        # Just seconds
        return float(time_str)

def extract_audio(input_file, start_time, end_time, output_file=None):
    """Extract audio segment using ffmpeg"""
    if output_file is None:
        # Create output filename based on input
        input_path = Path(input_file)
        output_file = f"{input_path.stem}_extract_{start_time}s-{end_time}s{input_path.suffix}"
    
    # Ensure tmp directory exists
    tmp_dir = Path("tmp")
    tmp_dir.mkdir(exist_ok=True)
    
    # If output_file is a temp file, put it in tmp directory
    if output_file.startswith("temp_") or output_file.startswith("looped_"):
        output_file = tmp_dir / output_file
    
    duration = end_time - start_time
    
    # Always re-encode for segment extraction to avoid corruption issues
    # This is especially important for MP3 files which don't handle stream copy well
    cmd = [
        'ffmpeg',
        '-i', input_file,
        '-ss', str(start_time),
        '-t', str(duration),
        '-y',  # Overwrite output file
        output_file
    ]
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode == 0:
        print(f"Extracted audio segment: {output_file}")
        return str(output_file)
    else:
        print(f"Error extracting audio: {result.stderr}")
        return None

def loop_audio(input_files, start_time=None, end_time=None):
    """Loop audio using streaming approach - supports multiple files"""
    temp_files = []
    
    # Ensure tmp directory exists
    tmp_dir = Path("tmp")
    tmp_dir.mkdir(exist_ok=True)
    
    try:
        # Parse input files (comma-separated)
        if isinstance(input_files, str):
            file_list = [f.strip() for f in input_files.split(',')]
        else:
            file_list = [input_files]
        
        print(f"Looping {len(file_list)} audio file(s): {', '.join(file_list)}")
        print("Press Ctrl+C to stop...")
        
        # Stream directly to ffplay without creating large files
        print("Starting looped audio stream...")
        
        if len(file_list) == 1:
            # Single file - stream loop directly
            input_file = file_list[0]
            if start_time is not None and end_time is not None:
                # Extract segment and stream loop
                cmd = [
                    'ffmpeg',
                    '-stream_loop', '-1',  # Loop infinitely
                    '-i', input_file,
                    '-ss', str(start_time),
                    '-t', str(end_time - start_time),
                    '-f', 'wav',
                    '-acodec', 'pcm_s16le',
                    '-ar', '44100',
                    '-ac', '2',
                    '-'
                ]
            else:
                # Stream entire file loop
                cmd = [
                    'ffmpeg',
                    '-stream_loop', '-1',  # Loop infinitely
                    '-i', input_file,
                    '-f', 'wav',
                    '-acodec', 'pcm_s16le',
                    '-ar', '44100',
                    '-ac', '2',
                    '-'
                ]
        else:
            # Multiple files - create a temporary concatenated file first, then loop it
            concat_file = tmp_dir / f"concat_{os.getpid()}.wav"
            
            # First, create the concatenated version
            inputs = []
            filters = []
            
            for i, file_path in enumerate(file_list):
                inputs.extend(['-i', file_path])
                if start_time is not None and end_time is not None:
                    filters.append(f'[{i}:a]atrim=start={start_time}:end={end_time}[a{i}]')
                else:
                    filters.append(f'[{i}:a]acopy[a{i}]')
            
            # Concatenate all segments
            concat_inputs = ''.join([f'[a{i}]' for i in range(len(file_list))])
            filters.append(f'{concat_inputs}concat=n={len(file_list)}:v=0:a=1[out]')
            
            concat_cmd = [
                'ffmpeg'
            ] + inputs + [
                '-filter_complex', ';'.join(filters),
                '-map', '[out]',
                '-f', 'wav',
                '-acodec', 'pcm_s16le',
                '-ar', '44100',
                '-ac', '2',
                '-y',
                str(concat_file)
            ]
            
            print("Creating concatenated version...")
            concat_result = subprocess.run(concat_cmd, capture_output=True, text=True)
            
            if concat_result.returncode != 0:
                print(f"Error creating concatenated version: {concat_result.stderr}")
                return False
            
            # Now stream loop the concatenated file
            cmd = [
                'ffmpeg',
                '-stream_loop', '-1',  # Loop infinitely
                '-i', str(concat_file),
                '-f', 'wav',
                '-acodec', 'pcm_s16le',
                '-ar', '44100',
                '-ac', '2',
                '-'
            ]
        
        # Stream directly to ffplay (which supports stdin)
        ffmpeg_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        player = subprocess.Popen(['ffplay', '-nodisp', '-'], stdin=ffmpeg_process.stdout)
        
        # Close the stdout of ffmpeg to allow it to receive a SIGPIPE if ffplay stops
        ffmpeg_process.stdout.close()
        
        # Wait for user to stop
        try:
            player.wait()
        except KeyboardInterrupt:
            pass
        
    except KeyboardInterrupt:
        print("\nStopping loop...")
    finally:
        # Clean up processes
        try:
            if 'player' in locals() and player and player.poll() is None:
                player.terminate()
        except:
            pass
        
        try:
            if 'ffmpeg_process' in locals() and ffmpeg_process and ffmpeg_process.poll() is None:
                ffmpeg_process.terminate()
        except:
            pass
        
        # Clean up temp files
        for temp_file in temp_files:
            if os.path.exists(temp_file):
                os.remove(temp_file)
        if 'concat_file' in locals() and os.path.exists(concat_file):
            os.remove(concat_file)
    
    return True

def main():
    # Clean up old temp files on startup
    cleanup_old_temp_files()
    
    parser = argparse.ArgumentParser(description='Music CLI Tool')
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Extract command
    extract_parser = subparsers.add_parser('extract', help='Extract audio segment')
    extract_parser.add_argument('input_file', help='Input audio file')
    extract_parser.add_argument('--start', required=True, help='Start time (e.g., :10 or 1:30)')
    extract_parser.add_argument('--end', required=True, help='End time (e.g., :30 or 2:00)')
    extract_parser.add_argument('--output', help='Output file (optional)')
    
    # Loop command
    loop_parser = subparsers.add_parser('loop', help='Loop audio (supports multiple files separated by commas)')
    loop_parser.add_argument('input_files', help='Input audio file(s) - use commas to separate multiple files')
    loop_parser.add_argument('--start', help='Start time (e.g., :10 or 1:30)')
    loop_parser.add_argument('--end', help='End time (e.g., :30 or 2:00)')
    
    args = parser.parse_args()
    
    if args.command == 'extract':
        start_time = parse_time(args.start)
        end_time = parse_time(args.end)
        
        if start_time >= end_time:
            print("Error: Start time must be before end time")
            sys.exit(1)
        
        extract_audio(args.input_file, start_time, end_time, args.output)
        
    elif args.command == 'loop':
        start_time = None
        end_time = None
        
        if args.start and args.end:
            start_time = parse_time(args.start)
            end_time = parse_time(args.end)
            
            if start_time >= end_time:
                print("Error: Start time must be before end time")
                sys.exit(1)
        
        loop_audio(args.input_files, start_time, end_time)
        
    else:
        parser.print_help()

if __name__ == '__main__':
    main()